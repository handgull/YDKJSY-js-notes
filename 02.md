# Ispezionando JS

## Ogni File è un Programma
In JS, ogni file autonomo è un programma separato.

La ragione di ciò riguarda principalmente la gestione degli errori. Poiché JS tratta i file come programmi, un file può fallire (durante l'analisi/compilazione o l'esecuzione) senza necessariamente impedire l'elaborazione del file successivo. Ovviamente, se la tua applicazione dipende da cinque file .js e uno di essi fallisce, l'applicazione nel complesso probabilmente funzionerà solo parzialmente, nel migliore dei casi. È importante assicurarsi che ciascun file funzioni correttamente e che, per quanto possibile, gestiscano il fallimento degli altri file nel modo più elegante possibile.

Potrebbe sorprenderti considerare file .js separati come programmi JS distinti. Dal tuo punto di vista dell'uso dell'applicazione, sembra certamente un unico grande programma. Questo perché l'esecuzione dell'applicazione consente a questi programmi individuali di cooperare e agire come un unico programma.

| NOTA: |
| :--- |
| Molti progetti utilizzano strumenti di processo di compilazione che combinano file separati del progetto in un singolo file da consegnare a una pagina web. Quando ciò accade, JS tratta questo singolo file combinato come l'intero programma.

L'unico modo in cui file .js autonomi agiscono come un singolo programma è condividendo il loro stato (e l'accesso alla loro funzionalità pubblica) tramite lo "scope globale". Si mescolano in questo spazio dei nomi dello scope globale, quindi a tempo di esecuzione agiscono come un tuttuno.

Da ES6, JS supporta anche un formato modulo oltre al formato tipico di programma JS autonomo. Anche i moduli sono basati su file. Se un file viene caricato tramite un meccanismo di caricamento modulo come un'istruzione di importazione o un tag 
```html
<script type=module>
```
tutto il suo codice è trattato come un singolo modulo.

Anche se di solito penseresti a un modulo, una raccolta di stato e metodi esposti pubblicamente per operare su tale stato, come a un programma autonomo, JS in realtà tratta ancora ogni modulo separatamente. Similmente a come lo "scope globale" permette ai file autonomi di mescolarsi a tempo di esecuzione, importare un modulo in un altro consente l'interoperabilità a tempo di esecuzione tra di essi.

Indipendentemente dal modello di organizzazione del codice (e dal meccanismo di caricamento) utilizzato per un file (autonomo o modulo), dovresti comunque considerare ogni file come il proprio (mini) programma, che può poi cooperare con altri (mini) programmi per svolgere le funzioni della tua applicazione complessiva.

## Valori

L'unità più fondamentale di informazione in un programma è un valore. I valori sono dati. Sono il modo in cui un programma mantiene lo stato. I valori in JS si presentano in due forme: primitivi e oggetti.

```js
greeting('My name is Kyle.'); // Il nome dell'autore del testo originale
```

In questo programma, il valore "My name is Kyle." è un letterale di stringa primitivo; le stringhe sono raccolte ordinate di caratteri.

Ho usato il carattere apice singolo per delimitare (racchiudere, separare, definire) il valore della stringa. Ma avrei potuto usare anche il carattere ". La scelta del carattere delimitatore è completamente stilistica. L'importante, per quanto riguarda la leggibilità e la manutenibilità del codice, è sceglierne uno e usarlo in modo coerente in tutto il programma.

Un'altra opzione per delimitare un letterale di stringa è utilizzare il carattere back-tick `. Tuttavia, questa scelta non è solo stilistica; c'è anche una differenza comportamentale:

```js
console.log("My name is ${ firstName }.");
// My name is ${ firstName }.

console.log('My name is ${ firstName }.');
// My name is ${ firstName }.

console.log(`My name is ${ firstName }.`);
// My name is Kyle.
```

Assumendo che questo programma abbia già definito una variabile firstName con il valore di stringa "Kyle", la stringa delimitata da ` risolve quindi l'espressione della variabile (indicata con ${ .. }) al suo valore attuale. Questo si chiama interpolazione.

La stringa delimitata da ` può essere utilizzata senza includere espressioni interpolate, ma ciò vanifica lo scopo di quella sintassi alternativa per i letterali di stringa!

Oltre alle stringhe, i programmi JS contengono spesso altri valori primitivi come booleani e numeri:

```js
while (false) {
    console.log(3.141592);
}
```

Oltre alle stringhe, numeri e booleani, altri due valori *primitivi* nei programmi JS sono `null` e `undefined`. Anche se esistono delle differenze tra di loro (alcune storiche e altre contemporanee), entrambi i valori servono principalmente a indicare *vuoto* (o assenza) di un valore.

Molti sviluppatori preferiscono trattarli entrambi in modo coerente, assumendo che i valori siano indistinguibili. Se si presta attenzione, ciò è spesso possibile. Tuttavia, è più sicuro e migliore utilizzare solo `undefined` come unico valore vuoto, anche se `null` sembra attraente perché è più breve da digitare!

```js
while (value != undefined) {
    console.log("C'è ancora qualcosa!");
}
```

L'ultimo valore primitivo di cui essere consapevoli è un simbolo, che è un valore a scopo speciale che funziona come un valore nascosto e imprevedibile. I simboli vengono utilizzati quasi esclusivamente come chiavi speciali sugli oggetti:

```js
hitchhikersGuide[ Symbol("meaning of life") ];
// 42
```

Sono utilizzati principalmente nel codice a basso livello come nelle librerie e nei framework.

## Array e Oggetti
Oltre ai tipi primitivi, l'altro tipo di valore in JS è un valore oggetto.

Gli array sono un tipo speciale di oggetto composto da un elenco ordinato e indicizzato numericamente di dati:

```js
var names = [ "Frank", "Kyle", "Peter", "Susan" ];

names.length;
// 4

names[0];
// Frank

names[1];
// Kyle
```

Gli array di JS possono contenere qualsiasi tipo di valore, sia primitivo che oggetto (inclusi altri array). Anche le funzioni sono valori che possono essere contenuti in array o oggetti.

| NOTA: |
| :--- |
| Le funzioni, come gli array, sono un tipo speciale (detto anche sottotipo) di oggetto. Tratteremo le funzioni in modo più dettagliato tra poco.

Gli oggetti sono più generali: una raccolta non ordinata e indicizzata da chiave di vari valori. In altre parole, si accede all'elemento tramite un nome di posizione stringa (detto "chiave" o "proprietà") anziché tramite la sua posizione numerica (come con gli array). Ad esempio:

```js
var me = {
    first: "Kyle",
    last: "Simpson",
    age: 39,
    specialties: [ "JS", "Table Tennis" ]
};

console.log(`My name is ${ me.first }.`);
```

Qui, `me` rappresenta un oggetto, e `first` rappresenta il nome di una posizione di informazione in quell'oggetto (raccolta di valori). Un'altra opzione di sintassi che accede alle informazioni in un oggetto tramite la sua proprietà/chiave utilizza le parentesi quadrate [ ], come me["first"].

## Determinazione del Tipo di Valore
Per distinguere i valori, l'operatore `typeof` ti dice il suo tipo incorporato, se primitivo, altrimenti "object":

```js
typeof 42;                  // "number"
typeof "abc";               // "string"
typeof true;                // "boolean"
typeof undefined;           // "undefined"
typeof null;                // "object" -- oops, bug!
typeof { "a": 1 };          // "object"
typeof [1,2,3];             // "object"
typeof function hello(){};  // "function"
```

| ATTENZIONE: |
| :--- |
| typeof null restituisce purtroppo "object" invece del previsto "null". Inoltre, typeof restituisce specificamente "function" per le funzioni, ma non il previsto "array" per gli array.

La conversione da un tipo di valore a un altro, come da stringa a numero, è definita in JS come "coercizione"

I valori primitivi e quelli oggetto si comportano diversamente quando vengono assegnati o passati in giro. I tipi primitivi vengono passati per valore, mentre gli oggetti per riferimento.

## Dichiarazione e Utilizzo delle Variabili
I valori possono apparire come valori letterali (come molti degli esempi precedenti illustrano) o possono essere contenuti in variabili; pensa alle variabili come semplicemente contenitori per i valori.

Le variabili devono essere dichiarate (create) per essere utilizzate. Ci sono diverse forme di sintassi che dichiarano le variabili, e ciascuna forma ha comportamenti impliciti diversi.

```js
// La parola chiave var dichiara una variabile da utilizzare in quella parte del programma e consente facoltativamente una assegnazione iniziale di un valore.
var myName = "Kyle";
var age;
// La parola chiave let ha alcune differenze rispetto a var, la più ovvia delle quali è che let consente un accesso più limitato alla variabile rispetto a var. Questo è chiamato "block scoping" rispetto a scoping regolare o di funzione.
let myName = "Kyle";
let age;

var adult = true;

if (adult) {
    var myName = "Kyle";
    let age = 39;
    console.log("Shhh, this is a secret!");
}

console.log(myName);
// Kyle

console.log(age);
// Error!

// Il tentativo di accedere a age al di fuori dell'istruzione if genera un errore, perché age è stato bloccato a livello di blocco nell'if, mentre myName no.
```

Il block-scoping è molto utile per limitare la diffusione delle dichiarazioni di variabili nei nostri programmi, il che aiuta a prevenire sovrapposizioni accidentali dei loro nomi.

Ma var è comunque utile nel senso che comunica "questa variabile sarà vista da uno scope più ampio (dell'intera funzione)". Entrambe le forme di dichiarazione possono essere appropriate in una determinata parte di un programma, a seconda delle circostanze.

| NOTA: |
| :--- |
| È molto comune suggerire di evitare var a favore di let (o const!), generalmente a causa della percezione di confusione su come si comporta lo scope di var fin dall'inizio di JS. Credo che questo sia un consiglio eccessivamente restrittivo e alla fine poco utile. Si presume che non si sia in grado di imparare e utilizzare correttamente una funzionalità in combinazione con altre funzionalità. Credo che si possa e si dovrebbe imparare qualsiasi funzionalità disponibile e utilizzarla dove appropriato!

Una terza forma di dichiarazione è const. È simile a let, ma ha un'ulteriore limitazione: deve essere assegnato un valore al momento della dichiarazione e non può essere ri-assegnato successivamente a un valore diverso.

Le variabili dichiarate con const non sono "immodificabili", semplicemente non possono essere ri-assegnate.

```js
const actors = [
    "Morgan Freeman", "Jennifer Aniston"
];

actors[2] = "Tom Cruise";   // OK
actors = [];                // Error!
```

Oltre a var / let / const, ci sono altre forme sintattiche che dichiarano identificatori (variabili) in vari scope. Ad esempio:

```js
function hello(myName) {
    console.log(`Hello, ${ myName }.`);
}

hello("Kyle");
// Hello, Kyle.
```

L'identificatore hello viene creato nello scope esterno ed è anche automaticamente associato in modo che faccia riferimento alla funzione. Ma il parametro nominato myName viene creato solo all'interno della funzione e quindi è accessibile solo all'interno dello scope di quella funzione. hello e myName si comportano in generale come se dichiarati con var.

Un'altra sintassi che dichiara una variabile è una clausola catch:

```js
try {
    someError();
}
catch (err) {
    console.log(err);
}
```

err è una variabile block-scoped che esiste solo all'interno della clausola catch, come se fosse stata dichiarata con let.