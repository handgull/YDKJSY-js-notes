# You Don't Know JS Yet: Get Started - readaptation by handgull

# Capitolo 4: Il Quadro Generale

Questo capitolo finale suddivide l'organizzazione del linguaggio JS in tre pilastri principali, offrendo poi una breve panoramica di ciò che ci si può aspettare dal resto della serie di libri e come suggerisco di procedere. Inoltre, non trascurare le appendici, in particolare l'appendice B, "Pratica, Pratica, Pratica!".

## Pilastro 1: Scope e Closure
L'organizzazione delle variabili in unità di scope (funzioni, blocchi) è una delle caratteristiche più fondamentali di qualsiasi linguaggio; forse nessun'altra caratteristica ha un maggiore impatto sul comportamento dei programmi.

Gli scope sono come secchielli e le variabili sono come biglie che vengono messe in quei secchielli. Il modello di scope di un linguaggio è simile alle regole che ti aiutano a determinare quali biglie colorate vanno in quali secchielli dello stesso colore.

Gli scope si annidano l'uno dentro l'altro, e per qualsiasi espressione o istruzione, solo le variabili a quel livello di annidamento dello scope, o negli scope superiori/esterni, sono accessibili; le variabili negli scope inferiori/interni sono nascoste e non accessibili.

Questo è il comportamento degli scope nella maggior parte dei linguaggi, chiamato scope lessicale. I confini dell'unità di scope e come le variabili sono organizzate al loro interno sono determinati al momento in cui il programma viene analizzato ("compilato"). In altre parole, è una decisione dell'autore: dove si posiziona una funzione/scope nel programma determina quale sarà la struttura dello scope di quella parte del programma.

JS ha uno scope lessicale, anche se molti sostengono il contrario, a causa di due caratteristiche particolari del suo modello che non sono presenti in altri linguaggi con scope lessicali.

La prima è comunemente chiamata *hoisting*: quando tutte le variabili dichiarate in qualsiasi punto di uno scope vengono trattate come se fossero dichiarate all'inizio dello scope. L'altra è che le variabili dichiarate con `var` hanno uno scope di funzione, anche se appaiono all'interno di un blocco.

Né l'hoisting né le variabili dichiarate con `var` e con scope di funzione sono sufficienti a sostenere l'affermazione che JS non abbia uno scope lessicale. Le dichiarazioni `let`/`const` hanno un comportamento particolare chiamato "Zona Morta Temporale" (TDZ) che porta a variabili osservabili ma non utilizzabili. Anche se la TDZ può sembrare strana, *anche* essa non invalida lo scope lessicale. Tutti questi sono semplicemente aspetti unici del linguaggio che dovrebbero essere appresi e compresi da tutti gli sviluppatori JS.

La Closure è il risultato naturale dello scope lessicale quando il linguaggio ha le funzioni come valori di prima classe, come avviene in JS. Quando una funzione fa riferimento a variabili da uno scope esterno e quella funzione viene passata come valore ed eseguita in altri scope, mantiene l'accesso alle sue variabili dello scope originale; questo è il concetto di Closure.

In tutta la programmazione, ma soprattutto in JS, la Closure guida molti dei pattern di programmazione più importanti, inclusi i moduli. Per come la vedo, i moduli sono il massimo della *convenienza*, per quanto riguarda l'organizzazione del codice in JS.

Per approfondire ulteriormente scope, Closure e come funzionano i moduli, leggi il Libro 2, *Scope & Closures*.

## Pilastro 2: Prototipi
Il secondo pilastro del linguaggio è il sistema dei prototipi. Abbiamo approfondito questo argomento nel Capitolo 3 ("Prototipi"), ma vorrei fare alcuni commenti in più sulla sua importanza.

JS è uno dei pochissimi linguaggi in cui hai l'opzione di creare oggetti direttamente ed esplicitamente, senza definire preventivamente la loro struttura in una classe.

Per molti anni, le persone hanno implementato il design pattern delle classi sui prototipi, il cosiddetto "ereditarietà prototipale" (vedi Appendice A, "Classi prototipali"), e poi, con l'avvento della parola chiave `class` di ES6, il linguaggio ha rafforzato la sua inclinazione verso la programmazione orientata agli oggetti/stile classi.

Ma penso che questo focus abbia oscurato la bellezza e la potenza del sistema dei prototipi: la capacità per due oggetti di semplicemente collegarsi tra loro e cooperare dinamicamente (durante l'esecuzione di funzioni/metodi) condividendo un contesto `this`.

Le classi sono solo un pattern su cui puoi costruire sopra tale potenza. Ma un altro approccio, in una direzione molto diversa, è semplicemente abbracciare gli oggetti come oggetti, dimenticando del tutto le classi, e lasciare che gli oggetti cooperino attraverso la catena dei prototipi. Questo è chiamato *delegazione di comportamento*. Ritengo che la delegazione sia più potente dell'ereditarietà delle classi come mezzo per organizzare il comportamento e i dati nei nostri programmi.

Ma l'ereditarietà delle classi riceve quasi tutta l'attenzione. Il resto va alla programmazione funzionale (FP), come una sorta di modo "anti-classe" di progettare i programmi. Questo mi rattrista, perché sopprime ogni possibilità di esplorare la delegazione come alternativa valida.

Ti incoraggio a dedicare molto tempo al Libro 3, *Oggetti e Classi*, per vedere come la delegazione degli oggetti offre molto più potenziale di quanto forse abbiamo realizzato. Questo non è un messaggio anti-`class`, ma è intenzionalmente un messaggio che afferma "le classi non sono l'unico modo per utilizzare gli oggetti" che vorrei che più sviluppatori JS considerassero.

La delegazione degli oggetti è, io arguirei, molto più *congruente* con JS rispetto alle classi (ulteriori informazioni sui *congruenti* tra poco).
