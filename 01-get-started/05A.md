# You Don't Know JS Yet: Get Started - readaptation by handgull

# Appendice A: Approfondimento

In questa appendice, esploreremo alcuni argomenti del testo principale del capitolo in modo più dettagliato. Puoi considerare questi contenuti come un'anteprima opzionale di alcuni dettagli più sfumati trattati nel resto della serie di libri.

## Valori vs. Riferimenti
Nel Capitolo 2, abbiamo introdotto i due principali tipi di valori: primitivi e oggetti. Tuttavia, non abbiamo ancora discusso una differenza chiave tra i due: come questi valori vengono assegnati e passati.

In molti linguaggi, lo sviluppatore può scegliere tra l'assegnare/passare un valore come il valore stesso o come un riferimento al valore. In JavaScript, invece, questa decisione è interamente determinata dal tipo di valore. Questo sorprende molti sviluppatori di altri linguaggi quando iniziano a usare JS.

Se assegni/passi un valore stesso, il valore viene copiato. Per esempio:

```js
var myName = "Kyle";

var yourName = myName;
```

Qui, la variabile `yourName` ha una copia separata della stringa "Kyle" rispetto al valore memorizzato in `myName`. Questo perché il valore è un primitivo, e i valori primitivi vengono sempre assegnati/passati come copia del valore.

Ecco come puoi dimostrare che ci sono due valori separati coinvolti:

```js
var myName = "Kyle";

var yourName = myName;

myName = "Frank";

console.log(myName);
// Frank

console.log(yourName);
// Kyle
```

Hai notato come `yourName` non è stato influenzato dalla ri-assegnazione di `myName` a "Frank"? Questo perché ogni variabile detiene la propria copia del valore.

Al contrario, i riferimenti sono l'idea che due o più variabili puntino allo stesso valore, tale che modificare questo valore condiviso sarebbe riflesso dall'accesso tramite uno qualsiasi di quei riferimenti. In JavaScript, solo i valori degli oggetti (array, oggetti, funzioni, ecc.) sono trattati come riferimenti.

```js
var myAddress = {
    street: "123 JS Blvd",
    city: "Austin",
    state: "TX"
};

var yourAddress = myAddress;

// I've got to move to a new house!
myAddress.street = "456 TS Ave";

console.log(yourAddress.street);
// 456 TS Ave
```

Poiché il valore assegnato a `myAddress` è un oggetto, è detenuto/assegnato per riferimento, e quindi l'assegnazione alla variabile `yourAddress` è una copia del riferimento, non del valore dell'oggetto stesso. Ecco perché il valore aggiornato assegnato a `myAddress.street` viene riflesso quando accediamo a `yourAddress.street`. `myAddress` e `yourAddress` hanno copie del riferimento all'oggetto condiviso singolo, quindi un aggiornamento ad uno è un aggiornamento per entrambi.

Ancora una volta, JavaScript sceglie il comportamento di copia-valore vs. copia-riferimento in base al tipo di valore. I primitivi sono detenuti per valore, gli oggetti sono detenuti per riferimento. Non c'è modo di sovrascrivere questo comportamento in JavaScript, in nessuna delle due direzioni.
